### 项目中使用slf4j和log4j打印日志

&emsp;&emsp;在项目开发中经常需要打印系统日志，用来定位问题，了解系统运行状态等等。目前市场上有许多日志类库，比如：log4j、logback、java.util.Logging等。常见的组合有slf4j + log4j。那什么是slf4j，它和log4j之间有什么联系呢？

#### slf4j简介

&emsp;&emsp;slf4j(Simple logging Facade for Java)不同于其它日志类库，它不是一个真正的日志实现，而是一个抽象，定义了一些日志常用的操作。slf4j必须和具体的日志实现类库(例如log4j)配合使用，slf4j在初始化的时候会从classpath中查找具体的实现类。使用slf4j可以很方便的实现日志类库之间的迁移(例如：从log4j迁移到logback，只需要将log4j的实现包替换为logback的实现包即可)。

#### slf4j+log4j的pom依赖

- Log4j_1.x

  ```xml
  <!--如果是log4j1.X版本，直接添加依赖slf4j-log4j12即可-->
  <dependency>
      <groupId>org.slf4j</groupId>
      <artifactId>slf4j-log4j12</artifactId>
      <version>1.7.25</version>
  </dependency>
  ```

  slf4j-log4j12依赖了slf4j-api、log4j，依赖关系如下图所示：
  ![log4j_pom_1](G:\Java\log4j\images\log4j_pom_1.PNG)

- Log4j_2.x

  ```xml
  <!--如果是log4j2.X版本，直接添加log4j-slf4j-impl即可-->
  <dependency>
      <groupId>org.apache.logging.log4j</groupId>
      <artifactId>log4j-slf4j-impl</artifactId>
      <version>2.11.2</version>
  </dependency>
  ```

  log4j-slf4j-impl依赖了slf4j-api、log4j-api、log4j-core，依赖关系如下图所示：
  ![log4j_pom](G:\Java\log4j\images\log4j_pom.PNG)

#### 配置文件

- Log4j_1.x
  log4j_1.x里默认配置文件名称为log4j.properties或者log4j.xml，相关配置信息如下所示：

  ```properties
  log4j.rootLogger=INFO,logfile
  
  log4j.appender.console=org.apache.log4j.ConsoleAppender
  log4j.appender.console.Threshold=INFO
  log4j.appender.console.immediateFlush=true
  log4j.appender.console.layout=org.apache.log4j.PatternLayout
  log4j.appender.console.layout.ConversionPattern=%d{yyyy-MM-dd HH:mm:ss} %4r %5p %c{2}:%L - %m%n
  
  log4j.appender.logfile=org.apache.log4j.DailyRollingFileAppender
  log4j.appender.logfile.File=./log4j-test.log
  log4j.appender.logfile.DataPattern='.'yyyy-MM-dd-HH-mm
  log4j.appender.logfile.encoding=UTF-8
  log4j.appender.logfile.immediateFlush=true
  log4j.appender.logfile.Append=true
  log4j.appender.logfile.layout=org.apache.log4j.PatternLayout
  log4j.appender.logfile.layout.ConversionPattern= %d{yyyy-MM-dd HH:mm:ss} %4r %5p %c{2}:%L - %m%n
  ```

- Log4j_2.x
  在log4j_2.x里默认配置文件名称为log4j2.properties，相关配置信息如下所示：

  ```xml
  <?xml version="1.0" encoding="UTF-8"?>
  <!-- monitorInterval，配置为120，单位为秒。即在服务运行过程中发生了log4j2配置文件的修改，log4j2能够在monitorInterval时间范围重新加载配置，无需重启应用。-->
  <Configuration status="WARN" monitorInterval="120">
      <properties>
          <!--当输出到文件中的时候使用LOG_HOME替代输出到的文件夹,类似于配置java环境的时候的JAVA_HOME的做法-->
          <!--最好是填写相对路径,基路径是当前项目也就是src的上一级别-->
          <!--如果写成testlog/mylog,即使没有testlog,也会在src同级目录下新建出testlog文件夹以及其下的mylog文件夹-->
          <property name="LOG_HOME">testlog/mylog</property>
      </properties>
  
      <!--翻译：附加器,记录方式-->
      <Appenders>
  
          <!--appenders里的两个属性,分别为name=Console和name=log(两个名字是自己起的)-->
          <!--appenders属性同级的loggers中的root的level的值控制输出信息的严格级别,一般是info-->
          <!--root中的AppenderRef的ref写appenders中的name,在这里也就是添Console或log-->
  
          <!--name是自己命名的,target=SYSTEM_OUT表示输出到控制台-->
          <Console name="Console" target="SYSTEM_OUT">
              <!--pattern控制格式化输出的格式-->
              <!--例子:在代码中写入logger.info("info级别信息");-->
              <!--输出:12:8:34.501 [main] INFO  com.selton.Log4jTest - info级别信息-->
              <PatternLayout pattern="%d{H:m:s.S} [%t] %-5level %logger{36} - %msg%n"/>
          </Console>
  
          <!--临时日志生成-->
          <!--<File name="log" fileName="log/test.log" append="true">
              <PatternLayout pattern="%d{H:m:s.S} [%t] %-5level %logger{36} - %msg%n"/>
          </File>-->
  
          <!--fileName：日志存储路径,
          filePattern：历史日志封存路径。其中%d{yyyyMMddHH}表示了封存历史日志的时间单位（目前单位为小时，yyyy表示年，MM表示月，dd表示天，HH表示小时，mm表示分钟，ss表示秒，SS表示毫秒）。
          注意后缀，log4j2自动识别zip等后缀，表示历史日志需要压缩。-->
          <RollingRandomAccessFile name="File" immediateFlush="true" fileName="${LOG_HOME}/today.log"
                                   filePattern="${LOG_HOME}/history-%d{yyyy-MM-dd}.log">
  
              <!-- level，表示最低接受的日志级别，配置为INFO，即我们期望打印INFO级别以上的日志。-->
              <!--onMatch，表示当日志事件的日志级别与level一致时，应怎么做。一般为ACCEPT，表示接受。-->
              <!--onMismatch，表示日志事件的日志级别与level不一致时，应怎么做。一般为DENY，表示拒绝。也可以为NEUTRAL表示中立。-->
              <Filters>
  
                  <!--最下方的Root level="debug",如果不设置这句的话,4个级别信息都会打印,设置后,就会只打印INFO以及之上-->
                  <ThresholdFilter level="INFO" onMatch="ACCEPT" onMismatch="DENY"/>
              </Filters>
  
              <!--输出到文件夹中去-->
              <PatternLayout pattern="%d{y-M-d H:m:s.S} [%t] %-5level %logger{36} - %msg%n" />
              <!--<HTMLLayout pattern="%d{y-M-d H:m:s.S} [%t] %-5level %logger{36} - %msg%n" />-->
  
              <!--必配项,TriggeringPolicy(触发策略) -->
              <Policies>
                  <!--按天,划分日志文件-->
                  <TimeBasedTriggeringPolicy interval="1" modulate="true" />
              </Policies>
  
              <!--必配项,RolloverStrategy(覆盖策略)-->
              <!--<DefaultRolloverStrategy max="20"/>-->
          </RollingRandomAccessFile>
      </Appenders>
  
      <Loggers>
          <Root level="debug">
              <AppenderRef ref="File"/>
          </Root>
      </Loggers>
  </Configuration>
  ```

#### 项目使用

```java
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

public class App {
    public static void main(String[] args) {
        Logger logger = LoggerFactory.getLogger(App.class);
        logger.error("hello,world");
    }
}
```

**注意Logger和LoggerFactory的包路径，如果没有配置日志的输出级别，默认是Error级别**

#### 源码分析

*以log4j1.x版本为例*

##### 1.配置文件加载

- 流程图

  ```mermaid
  %% 时序图例子,-> 直线，-->虚线，->>实线箭头
  
    sequenceDiagram
  
      participant LogManager
      participant OptionConverter
      participant PropertyConfigurator
      
      LogManager ->> LogManager : static静态代码块(生成hierarchy和repositorySelector,解析配置文件url)
      LogManager ->> OptionConverter : selectAndConfigure
      OptionConverter ->> PropertyConfigurator : doConfigure
      PropertyConfigurator ->> PropertyConfigurator : 加载配置文件，执行doConfigure
      PropertyConfigurator ->> PropertyConfigurator : configureRootCategory
      PropertyConfigurator ->> PropertyConfigurator : configureLoggerFactory
      PropertyConfigurator ->> PropertyConfigurator : parseCatsAndRenderers
  ```

  

- 代码分析

1. 在LogManager的静态代码块中会执行配置文件的加载，代码如下：

   ```java
   static {
       //创建RootLogger，并生成Logger的级联关系h，构造出容器选择器repositorySelector对象
       Hierarchy h = new Hierarchy(new RootLogger((Level) Level.DEBUG));
       repositorySelector = new DefaultRepositorySelector(h);
   
       //是否使用默认配置覆盖，如果为true则不加载配置文件，直接使用log4j的默认配置
       String override = OptionConverter.getSystemProperty(DEFAULT_INIT_OVERRIDE_KEY, null);
   
       if (override == null || "false".equalsIgnoreCase(override)) {
   		//系统属性中是否通过log4j.configuration指定了配置文件或者通过log4j.configuratorClass指定了配置文件解析类
           String configurationOptionStr = OptionConverter.getSystemProperty(DEFAULT_CONFIGURATION_KEY, null);
           String configuratorClassName = OptionConverter.getSystemProperty(CONFIGURATOR_CLASS_KEY, null);
   
           URL url = null;
           if (configurationOptionStr == null) {
               //加载log4j.xml
               url = Loader.getResource(DEFAULT_XML_CONFIGURATION_FILE);
               //如果没有配置log4j.xml则加载log4j.properties
               if (url == null) {
                   url = Loader.getResource(DEFAULT_CONFIGURATION_FILE);
               }
           } else {
               //加载指定的配置文件
               try {
                   url = new URL(configurationOptionStr);
               } catch (MalformedURLException ex) {
                   url = Loader.getResource(configurationOptionStr);
               }
           }
   
           if (url != null) {
               LogLog.debug("Using URL [" + url + "] for automatic log4j configuration.");
               try {
                   //加载配置文件详细信息
                   OptionConverter.selectAndConfigure(url, configuratorClassName, LogManager.getLoggerRepository());
               } catch (NoClassDefFoundError e) {
                   LogLog.warn("Error during default initialization", e);
               }
           } else {
               //没有找到指定的配置文件
               LogLog.debug("Could not find resource: [" + configurationOptionStr + "].");
           }
       } else {
           //使用默认配置时候，不会加载配置文件
           LogLog.debug("Default initialization of overridden by " + DEFAULT_INIT_OVERRIDE_KEY + "property.");
       }
   }
   ```

2. OptionConverter.selectAndConfigure中获取解析配置文件类，并执行解析过程。

   ```java
   void selectAndConfigure(URL url, String clazz, LoggerRepository hierarchy) {
    	Configurator configurator = null;
       //需要加载的配置文件
    	String filename = url.getFile();	
   
       //如果是xml类型的配置文件，则使用DOMConfigurator进行解析
    	if(clazz == null && filename != null && filename.endsWith(".xml")) {
      		clazz = "org.apache.log4j.xml.DOMConfigurator";
    	}
   
    	if(clazz != null) {
           //如果指定了解析类，或者是xml类型的配置文件，则初始化解析类，如果错误则返回
      		LogLog.debug("Preferred configurator class: " + clazz);
      		configurator = (Configurator) instantiateByClassName(clazz, Configurator.class, null);
      		if(configurator == null) {
        		LogLog.error("Could not instantiate configurator ["+clazz+"].");
        		return;
      		}
    	} else {
           //如果没有指定解析类或者不是xml类型的配置文件，则使用Property文件解析
      		configurator = new PropertyConfigurator();
    	}
   	//解析配置文件
    	configurator.doConfigure(url, hierarchy);
   }
   ```

3. 在PropertyConfigurator.doConfigure通过FileInputStream加载log4j.properties配置文件，然后指定doConfigure执行具体的加载流程。

   ```java
   public void doConfigure(Properties properties, LoggerRepository hierarchy) {
   	repository = hierarchy;
       //是否允许全局debug操作
      	String value = properties.getProperty(LogLog.DEBUG_KEY);
      	if(value != null) {
        	LogLog.setInternalDebugging(OptionConverter.toBoolean(value, true));
      	}
   	//是否重置hierarchy（Logger的继承关系）
      	String reset = properties.getProperty(RESET_KEY);
      	if (reset != null && OptionConverter.toBoolean(reset, false)) {
            hierarchy.resetConfiguration();
      	}
   	//是否设置了全局日志级别门槛
      	String thresholdStr = OptionConverter.findAndSubst(THRESHOLD_PREFIX, properties);
      	if(thresholdStr != null) {
        	hierarchy.setThreshold(OptionConverter.toLevel(thresholdStr, (Level) Level.ALL));
        	LogLog.debug("Hierarchy threshold set to ["+hierarchy.getThreshold()+"].");
      	}
      	//配置RootLogger
      	configureRootCategory(properties, hierarchy);
       //配置LoggerFactory
      	configureLoggerFactory(properties);
       //解析具体的Logger
      	parseCatsAndRenderers(properties, hierarchy);
   
      LogLog.debug("Finished configuring.");
      // We don't want to hold references to appenders preventing their
      // garbage collection.
      registry.clear();
    }
   ```

4. 在PropertyConfigurator.parseCatsAndRenderers方法中解析具体的Logger

   ```java
   protected void parseCatsAndRenderers(Properties props, LoggerRepository hierarchy) {
      	Enumeration enumeration = props.propertyNames();
      	while(enumeration.hasMoreElements()) {
        	String key = (String) enumeration.nextElement();
           //以log4j.category或者log4j.logger开头的key
        	if(key.startsWith(CATEGORY_PREFIX) || key.startsWith(LOGGER_PREFIX)) {
               //获取loggerName
   			String loggerName = null;
   			if(key.startsWith(CATEGORY_PREFIX)) {
     				loggerName = key.substring(CATEGORY_PREFIX.length());
   			} else if(key.startsWith(LOGGER_PREFIX)) {
     				loggerName = key.substring(LOGGER_PREFIX.length());
   			}
               //获取Logger Value
   			String value =  OptionConverter.findAndSubst(key, props);
               //根据名称获取logger，如果在hierarchy中不存在则创建新的Logger对象，并设置parent对象。
   			Logger logger = hierarchy.getLogger(loggerName, loggerFactory);
               synchronized(logger) {
                   //解析Logger的category属性，包括解析Appender并将Appender添加到Logger对象中
                 	parseCategory(props, logger, key, loggerName, value);
                 	parseAdditivityForLogger(props, logger, loggerName);
               }
        	} else if(key.startsWith(RENDERER_PREFIX)) {
               String renderedClass = key.substring(RENDERER_PREFIX.length());
               String renderingClass = OptionConverter.findAndSubst(key, props);
               if(hierarchy instanceof RendererSupport) {
                 	RendererMap.addRenderer((RendererSupport) hierarchy, renderedClass, renderingClass);
               }
        	} else if (key.equals(THROWABLE_RENDERER_PREFIX)) {
            	if (hierarchy instanceof ThrowableRendererSupport) {
              		ThrowableRenderer tr = (ThrowableRenderer)
               	OptionConverter.instantiateByKey(props, THROWABLE_RENDERER_PREFIX, org.apache.log4j.spi.ThrowableRenderer.class, null);
              		if(tr == null) {
                  		LogLog.error("Could not instantiate throwableRenderer.");
              		} else {
                  		PropertySetter setter = new PropertySetter(tr);
                  		setter.setProperties(props, THROWABLE_RENDERER_PREFIX + ".");
                  		((ThrowableRendererSupport) hierarchy).setThrowableRenderer(tr);
                   }
            	}
        	}
      	}
    }
   ```

##### 2.Logger&LoggerFactory初始化

- 流程图

  ```mermaid
  %% 时序图例子,-> 直线，-->虚线，->>实线箭头
  
    sequenceDiagram
  
      participant LoggerFactory
      participant StaticLoggerBinder
      participant Log4jLoggerFactory
      participant LogManager
      participant Hierarchy
      participant DefaultCategoryFactory
      participant Logger
      
      LoggerFactory ->> LoggerFactory : getLogger 
      LoggerFactory ->> LoggerFactory : getILoggerFactory：获取Logger工厂
      LoggerFactory ->> LoggerFactory : performInitialization:执行初始化
      LoggerFactory ->> LoggerFactory : bind:初始化StaticLoggerBinder
      LoggerFactory ->> StaticLoggerBinder : new StaticLoggerBinder()
      StaticLoggerBinder ->> Log4jLoggerFactory : new Log4jLoggerFactory()
      Log4jLoggerFactory -->> StaticLoggerBinder : 返回Log4jLoggerFactory实例
      StaticLoggerBinder -->> LoggerFactory : 返回StaticLoggerBinder实例
      LoggerFactory ->> Log4jLoggerFactory : getLogger(name)
      Log4jLoggerFactory ->> LogManager : getLogger(name)
      LogManager ->> Hierarchy : getLogger(name)
      Hierarchy ->> DefaultCategoryFactory : makeNewLoggerInstance
      DefaultCategoryFactory ->> Logger : new Logger(name)
      Logger -->> DefaultCategoryFactory : Logger实例
      DefaultCategoryFactory -->> Hierarchy : Logger实例
      Hierarchy -->> LogManager : Logger实例
      LogManager -->> Log4jLoggerFactory : Logger实例
      Log4jLoggerFactory -->> LoggerFactory : Logger实例
  ```

  

- 源码分析

  1. 调用LoggerFactory.getLogger获取Logger对象

     ```java
     public static Logger getLogger(String name) {
         //获取LoggerFactory实现，如果是Log4j，则具体的实现类是Log4jLoggerFactory
         ILoggerFactory iLoggerFactory = getILoggerFactory();
         //通过getLogger方法获取对应的Logger
         return iLoggerFactory.getLogger(name);
     }
     ```

  2. 在getILoggerFactory中执行LoggerFactory的初始化工作

     ```java
     public static ILoggerFactory getILoggerFactory() {
         if (INITIALIZATION_STATE == UNINITIALIZED) {
             synchronized (LoggerFactory.class) {
                 if (INITIALIZATION_STATE == UNINITIALIZED) {
                     INITIALIZATION_STATE = ONGOING_INITIALIZATION;
                     //LoggerFactory的初始化
                     performInitialization();
                 }
             }
         }
         
         switch (INITIALIZATION_STATE) {
             case SUCCESSFUL_INITIALIZATION:
                 //返回LoggerFactory对象
                 return StaticLoggerBinder.getSingleton().getLoggerFactory();
             case NOP_FALLBACK_INITIALIZATION:
                 return NOP_FALLBACK_FACTORY;
             case FAILED_INITIALIZATION:
                 throw new IllegalStateException(UNSUCCESSFUL_INIT_MSG);
             case ONGOING_INITIALIZATION:
                 return SUBST_FACTORY;
         }
         throw new IllegalStateException("Unreachable code");
     }
     ```

  3. performInitialization方法内部执行bind方法，在bind方法内部通过调用`StaticLoggerBinder.getSingleton();`来初始化StaticLoggerBinder实例

     ```java
     private final static void bind() {
         try {
             Set<URL> staticLoggerBinderPathSet = null;
             if (!isAndroid()) {
                 //查找StaticLoggerBinder的实现类
                 staticLoggerBinderPathSet = findPossibleStaticLoggerBinderPathSet();
                 //判断是否有多个实现
                 reportMultipleBindingAmbiguity(staticLoggerBinderPathSet);
             }
             // 单例方法初始化StaticLoggerBinder，进而初始化Log4jLoggerFactory
             StaticLoggerBinder.getSingleton();
             INITIALIZATION_STATE = SUCCESSFUL_INITIALIZATION;
             reportActualBinding(staticLoggerBinderPathSet);
             fixSubstituteLoggers();
             replayEvents();
             SUBST_FACTORY.clear();
         } catch (NoClassDefFoundError ncde) {
             //......
         } catch (java.lang.NoSuchMethodError nsme) {
             //......
         } catch (Exception e) {
             failedBinding(e);
             throw new IllegalStateException("Unexpected initialization failure", e);
         }
     }
     ```

  4. StaticLoggerBinder采用单例模式，并且在构造方法中生成了Log4jLoggerFactory对象

     ```java
     //单例模式
     private static final StaticLoggerBinder SINGLETON = new StaticLoggerBinder();
     public static final StaticLoggerBinder getSingleton() {
         return SINGLETON;
     }
     //构造方法
     private StaticLoggerBinder() {
         //初始化Log4jLoggerFactory对象
         loggerFactory = new Log4jLoggerFactory();
         try {
             @SuppressWarnings("unused")
             Level level = Level.TRACE;
         } catch (NoSuchFieldError nsfe) {
             Util.report("This version of SLF4J requires log4j version 1.2.12 or later. See also http://www.slf4j.org/codes.html#log4j_version");
         }
     }
     ```

  5. `Log4jLoggerFactory`的构造方法中初始化LogManager(加载配置文件，生成Logger对象，详细流程参考 **配置文件加载** 源码分析)

     ```java
     public Log4jLoggerFactory() {
         loggerMap = new ConcurrentHashMap<String, Logger>();
         // 初始化LogManager，先执行static静态代码块，然后执行getRootLogger方法。
         org.apache.log4j.LogManager.getRootLogger();
     }
     ```

  6. LoggerFactory生成以后调用getLogger方法获取Logger实例

     ```java
     public Logger getLogger(String name) {
         //loggerMap对logger实例进行缓存
         Logger slf4jLogger = loggerMap.get(name);
         if (slf4jLogger != null) {
             return slf4jLogger;
         } else {
             org.apache.log4j.Logger log4jLogger;
             //获取RootLogger实例
             if (name.equalsIgnoreCase(Logger.ROOT_LOGGER_NAME))
                 log4jLogger = LogManager.getRootLogger();
             else
                 //根据名字获取logger实例
                 log4jLogger = LogManager.getLogger(name);
     		//适配器模式
             Logger newInstance = new Log4jLoggerAdapter(log4jLogger);
             //生成的logger对象进行缓存
             Logger oldInstance = loggerMap.putIfAbsent(name, newInstance);
             return oldInstance == null ? newInstance : oldInstance;
         }
     }
     ```

  7. LoggerFactory调用LogManager.getLogger方法获取对应名称的Logger实例

     ```
     public static  Logger getLogger(final String name) {
        // getLoggerRepository()返回的是static代码块中构造的Hierarchy实例对象，然后调用Hierarchy的getLogger方法
       return getLoggerRepository().getLogger(name);
     }
     ```

  8. Hierarchy.getLogger方法生成对应的logger实例

     ```java
     public Logger getLogger(String name) {
         //defaultFactory是DefaultCategoryFactory类型
       	return getLogger(name, defaultFactory);
     }
     public Logger getLogger(String name, LoggerFactory factory) {
         CategoryKey key = new CategoryKey(name);
         
         Logger logger;
         synchronized(ht) {
             //
           	Object o = ht.get(key);
           	if(o == null) {
                 //生成logger实例
     			logger = factory.makeNewLoggerInstance(name);
                 //设置继承对象
     			logger.setHierarchy(this);
                 //hashTable缓存结果
     			ht.put(key, logger);
                 //更新parent对象
     			updateParents(logger);
     			return logger;
           	} else if(o instanceof Logger) {
     			return (Logger) o;
           	} else if (o instanceof ProvisionNode) {
                 //System.out.println("("+name+") ht.get(this) returned ProvisionNode");
                 logger = factory.makeNewLoggerInstance(name);
                 logger.setHierarchy(this);
                 ht.put(key, logger);
                 updateChildren((ProvisionNode) o, logger);
                 updateParents(logger);
                 return logger;
           	}
           	else {
                 // It should be impossible to arrive here
                 return null;  // but let's keep the compiler happy.
           	}
         }
     }
     ```

  9. ```java
     DefaultCategoryFactory中调用makeNewLoggerInstance生成Logger对象
     public Logger makeNewLoggerInstance(String name) {
         return new Logger(name);
     }
     ```

##### 3.日志输出

通过代码`logger.error("hello,world");`可以输出日志内容

- 流程图
- 源码分析

```sequence
Log4jLogger -> Log4jLogger : error
Log4jLogger -> AbstractLogger : logIfEnabled
AbstractLogger -> Logger : isEnabled
Logger -> PrivateConfig : filter
AbstractLogger -> AbstractLogger : logMessage
AbstractLogger -> ReusableMessageFactory : newMessage
AbstractLogger -> AbstractLogger : logMessageSafely
AbstractLogger -> AbstractLogger : logMessageTrackRecursion
AbstractLogger -> Logger : logMessage
Logger -> DefaultReliabilityStrategy : log
DefaultReliabilityStrategy -> LoggerConfig :log
LoggerConfig -> ReusableLogEventFactory : createEvent
LoggerConfig -> LoggerConfig : log
LoggerConfig -> AbstractFilterable : isFiltered
LoggerConfig -> LoggerConfig : processLogEvent
LoggerConfig -> LoggerConfig : callAppenders
LoggerConfig -> AppenderControl : callAppender
AppenderControl -> AppenderControl : callAppenderPreventRecursion
AppenderControl -> AppenderControl : callAppender0
AppenderControl -> AppenderControl : tryCallAppender
AppenderControl -> AbstractOutputStreamAppender : append
AbstractOutputStreamAppender -> AbstractOutputStreamAppender : tryAppend
AbstractOutputStreamAppender -> AbstractOutputStreamAppender : directEncodeEvent
AbstractOutputStreamAppender -> PatternLayout : encode
AbstractOutputStreamAppender -> OutputStreamManager : flush
OutputStreamManager -> OutputStreamManager : flushBuffer
OutputStreamManager -> OutputStreamManager : flushDestination
```

#### 设计模式

* 单例模式：StaticLoggerBinder
* 工厂模式：LoggerFactory、Log4jLoggerFactory

* 适配器模式：Log4jLoggerAdapter

#### log4j性能测试

&emsp;测试条件：日志大小200B，日志条数10000条

* `ConsoleAppender`
  * `immediateFlush=false`：2796ms
  * `immediateFlush=true`：4518ms
* `DailyRollingFileAppender`
  * immediateFlush=false`：218ms
  * `immediateFlush=true`：250ms